from typing import (
    Any,
    Dict,
    Generic,
    Hashable,
    Iterable,
    List,
    Mapping,
    Optional,
    Set,
    Tuple,
    TypeVar,
)

Node = TypeVar("Node", bound=Hashable)
Edge = Tuple[Node, Node]
Self = TypeVar("Self", bound="Graph[Any]")

class NodeView(Mapping[Node, Any], Set[Node], Generic[Node]):
    pass

class OutEdgeView(Mapping[Edge[Node], Any], Set[Edge[Node]], Generic[Node]):
    pass

class InEdgeView(OutEdgeView[Node]):
    pass

class Graph(Generic[Node]):
    nodes: NodeView[Node]
    def add_node(self, node_for_adding: Node, **attr: Dict[Hashable, Any]) -> None: ...
    def add_edge(
        self, u_of_edge: Node, v_of_edge: Node, **attr: Dict[Hashable, Any]
    ) -> None: ...
    def has_edge(self, u: Node, v: Node) -> bool: ...
    def neighbors(self, n: Node) -> Iterable[Node]: ...
    def number_of_nodes(self) -> int: ...
    def number_of_edges(self) -> int: ...
    def copy(self: Self) -> Self: ...
    def subgraph(self: Self, nodes: List[Node]) -> Self: ...
    def __getitem__(self, n: Node) -> Dict[Hashable, Any]: ...

class DiGraph(Graph[Node]):
    def out_edges(self, nbunch: Node) -> OutEdgeView[Node]: ...
    def in_edges(self, nbunch: Node) -> InEdgeView[Node]: ...
    def in_degree(self, nbunch: Node) -> int: ...
    def out_degree(self, nbunch: Node) -> int: ...
    def reverse(self) -> DiGraph[Node]: ...

def set_edge_attributes(
    G: Graph[Node],
    values: Dict[Edge[Node], Dict[Hashable, Any]],
) -> None: ...
def has_path(G: Graph[Node], source: Hashable, target: Hashable) -> bool: ...
def simple_cycles(G: Graph[Node]) -> Iterable[List[Node]]: ...
def find_cycle(G: Graph[Node], source: Optional[Node] = None) -> List[Edge[Node]]: ...
def weakly_connected_components(G: DiGraph[Node]) -> Iterable[Set[Node]]: ...
def shortest_path(G: Graph[Node], s: Node) -> Dict[Node, List[Node]]: ...

class NetworkXNoCycle(Exception):
    """Exception for algorithms that should return a cycle when running
    on graphs where such a cycle does not exist."""
